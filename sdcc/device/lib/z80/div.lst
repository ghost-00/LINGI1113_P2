                              1         ;; Originally from GBDK by Pascal Felber.
                              2 
                              3         .area   _CODE
                              4 
   0000                       5 __divuint_rrx_s::
   0000 F1                    6         pop     af
   0001 E1                    7         pop     hl
   0002 D1                    8         pop     de
   0003 D5                    9         push    de
   0004 E5                   10         push    hl
   0005 F5                   11         push    af
                             12 
   0006 18 76                13         jr      __divu16
                             14 
   0008                      15 __divsuchar_rrx_s::
   0008 21 03 00             16         ld      hl,#2+1
   000B 39                   17         add     hl,sp
                             18 
   000C 5E                   19         ld      e,(hl)
   000D 2B                   20         dec     hl
   000E 6E                   21         ld      l,(hl)
   000F 26 00                22         ld      h,#0
                             23 
   0011 18 27                24         jr      signexte
                             25 
   0013                      26 __modsuchar_rrx_s::
   0013 21 03 00             27         ld      hl,#2+1
   0016 39                   28         add     hl,sp
                             29 
   0017 5E                   30         ld      e,(hl)
   0018 2B                   31         dec     hl
   0019 6E                   32         ld      l,(hl)
   001A 26 00                33         ld      h,#0
                             34 
   001C CDr3As00             35         call    signexte
                             36 
   001F EB                   37         ex      de,hl
   0020 C9                   38         ret
                             39 
   0021                      40 __divuschar_rrx_s::
   0021 21 03 00             41         ld      hl,#2+1
   0024 54                   42         ld      d, h
   0025 39                   43         add     hl,sp
                             44 
   0026 5E                   45         ld      e,(hl)
   0027 2B                   46         dec     hl
   0028 6E                   47         ld      l,(hl)
                             48 
   0029 7D                   49         ld      a,l             ; Sign extend
   002A 07                   50         rlca
   002B 9F                   51         sbc     a
   002C 67                   52         ld      h,a
                             53 
   002D 18 0F                54         jr      __div16
                             55 
   002F                      56 __divschar_rrx_s::
   002F 21 03 00             57         ld      hl,#2+1
   0032 39                   58         add     hl,sp
                             59 
   0033 5E                   60         ld      e,(hl)
   0034 2B                   61         dec     hl
   0035 6E                   62         ld      l,(hl)
                             63 
                             64         ;; Fall through
   0036                      65 __divschar_rrx_hds::
   0036                      66 __div8::
   0036 7D                   67         ld      a,l             ; Sign extend
   0037 07                   68         rlca
   0038 9F                   69         sbc     a
   0039 67                   70         ld      h,a
   003A                      71 signexte:
   003A 7B                   72         ld      a,e             ; Sign extend
   003B 07                   73         rlca
   003C 9F                   74         sbc     a
   003D 57                   75         ld      d,a
                             76         ; Fall through to __div16
                             77 
                             78         ;; signed 16-bit division
                             79         ;;
                             80         ;; Entry conditions
                             81         ;;   HL = dividend
                             82         ;;   DE = divisor
                             83         ;;
                             84         ;; Exit conditions
                             85         ;;   HL = quotient
                             86         ;;   DE = remainder
                             87         ;;   If divisor is non-zero, carry=0
                             88         ;;   If divisor is 0, carry=1 and both quotient and remainder are 0
                             89         ;;
                             90         ;; Register used: AF,B,DE,HL
   003E                      91 __divsint_rrx_hds::
   003E                      92 __div16::
                             93         ;; Determine sign of quotient by xor-ing high bytes of dividend
                             94         ;;  and divisor. Quotient is positive if signs are the same, negative
                             95         ;;  if signs are different
                             96         ;; Remainder has same sign as dividend
   003E 7C                   97         ld      a,h             ; Get high byte of dividend
   003F AA                   98         xor     d               ; Xor with high byte of divisor
   0040 17                   99         rla                     ; Sign of quotient goes into the carry
   0041 7C                  100         ld      a,h             ; Get high byte of dividend
   0042 F5                  101         push    af              ; Save sign of both quotient and reminder
                            102 
                            103         ;; Take absolute value of dividend
   0043 17                  104         rla
   0044 30 06               105         jr      NC,.chkde       ; Jump if dividend is positive
   0046 97                  106         sub     a               ; Substract dividend from 0
   0047 95                  107         sub     l
   0048 6F                  108         ld      l,a
   0049 9F                  109         sbc     a               ; Propagate borrow (A=0xFF if borrow)
   004A 94                  110         sub     h
   004B 67                  111         ld      h,a
                            112         ;; Take absolute value of divisor
   004C                     113 .chkde:
   004C CB 7A               114         bit     7,d
   004E 28 06               115         jr      Z,.dodiv        ; Jump if divisor is positive
   0050 97                  116         sub     a               ; Substract divisor from 0
   0051 93                  117         sub     e
   0052 5F                  118         ld      e,a
   0053 9F                  119         sbc     a               ; Propagate borrow (A=0xFF if borrow)
   0054 92                  120         sub     d
   0055 57                  121         ld      d,a
                            122         ;; Divide absolute values
   0056                     123 .dodiv:
   0056 CDr7Es00            124         call    __divu16
   0059 38 14               125         jr      C,.exit         ; Exit if divide by zero
                            126         ;; Negate quotient if it is negative
   005B F1                  127         pop     af              ; recover sign of quotient
   005C 30 08               128         jr      NC,.dorem       ; Jump if quotient is positive
   005E 47                  129         ld      b,a
   005F 97                  130         sub     a               ; Substract quotient from 0
   0060 95                  131         sub     l
   0061 6F                  132         ld      l,a
   0062 9F                  133         sbc     a               ; Propagate borrow (A=0xFF if borrow)
   0063 94                  134         sub     h
   0064 67                  135         ld      h,a
   0065 78                  136         ld      a,b
   0066                     137 .dorem:
                            138         ;; Negate remainder if it is negative
   0066 17                  139         rla
   0067 D0                  140         ret     NC              ; Return if remainder is positive
   0068 97                  141         sub     a               ; Substract remainder from 0
   0069 93                  142         sub     e
   006A 5F                  143         ld      e,a
   006B 9F                  144         sbc     a               ; Propagate remainder (A=0xFF if borrow)
   006C 92                  145         sub     d
   006D 57                  146         ld      d,a
   006E C9                  147         ret
   006F                     148 .exit:
   006F F1                  149         pop     af
                            150 
   0070                     151 .dividebyzero:
   0070 62                  152         ld      h,d             ; Divide by zero error: D=E=0
   0071 6B                  153         ld      l,e
   0072 37                  154         scf                     ; Set carry, invalid result
   0073 C9                  155         ret
                            156 
                            157         ;; Unsigned
   0074                     158 __divuchar_rrx_s::
   0074 21 03 00            159         ld      hl,#2+1
   0077 39                  160         add     hl,sp
                            161 
   0078 5E                  162         ld      e,(hl)
   0079 2B                  163         dec     hl
   007A 6E                  164         ld      l,(hl)
                            165 
                            166         ;; Fall through
   007B                     167 __divuchar_rrx_hds::
   007B                     168 __divu8::
   007B 26 00               169         ld      h,#0x00
   007D 54                  170         ld      d,h
                            171         ; Fall through to divu16
                            172 
                            173         ;; unsigned 16-bit division
                            174         ;; Restructured on April 2009 by Marco Bodrato(http://bodrato.it/ )
                            175         ;;
                            176         ;; Entry conditions
                            177         ;;   HL = dividend
                            178         ;;   DE = divisor
                            179         ;;
                            180         ;; Exit conditions
                            181         ;;   HL = quotient
                            182         ;;   DE = remainder
                            183         ;;   If divisor is non-zero, carry=0
                            184         ;;   If divisor is 0, carry=1 and both quotient and remainder are 0
                            185         ;;
                            186         ;; Register used: AF,B,DE,HL
   007E                     187 __divuint_rrx_hds::
   007E                     188 __divu16::
                            189         ;; Check for division by zero
   007E 7B                  190         ld      a,e
   007F B2                  191         or      d
   0080 28 EE               192         jr      Z,.dividebyzero ; Branch if divisor is non-zero
                            193         ;; Two algorithms: one assumes divisor <2^7, the second
                            194         ;; assumes divisor >=2^7; choose the applicable one.
   0082 E6 80               195         and     #0x80
   0084 20 13               196         jr      NZ,.morethan7bits
   0086 B2                  197         or      d
   0087 20 10               198         jr      NZ,.morethan7bits
                            199         ;; Both algorithms "rotate" 24 bits (H,L,A) but roles change.
                            200 
                            201         ;; unsigned 16/7-bit division
                            202         ;; Rewrote on April 2009 by Marco Bodrato ( http://bodrato.it/ )
   0089                     203 .atmost7bits:
   0089 06 10               204         ld      b,#16           ; bits in dividend and possible quotient
                            205         ;; Carry cleared by AND/OR, this "0" bit will pass trough HL.[*]
   008B ED 6A               206         adc     hl,hl
   008D                     207 .dvloop7:
                            208         ;; HL holds both dividend and quotient. While we shift a bit from
                            209         ;;  MSB of dividend, we shift next bit of quotient in from carry.
                            210         ;; A holds remainder.
   008D 17                  211         rla
                            212 
                            213         ;; If remainder is >= divisor, next bit of quotient is 1.  We try
                            214         ;;  to compute the difference.
   008E 93                  215         sub     a,e
   008F 30 01               216         jr      NC,.nodrop7     ; Jump if remainder is >= dividend
   0091 83                  217         add     a,e             ; Otherwise, restore remainder
                            218         ;; The add above sets the carry, because sbc a,e did set it.
   0092                     219 .nodrop7:
   0092 3F                  220         ccf                     ; Complement borrow so 1 indicates a
                            221                                 ;  successful substraction (this is the
                            222                                 ;  next bit of quotient)
   0093 ED 6A               223         adc     hl,hl
   0095 10 F6               224         djnz    .dvloop7
                            225         ;; Carry now contains the same value it contained before
                            226         ;; entering .dvloop7[*]: "0" = valid result.
   0097 5F                  227         ld      e,a             ; DE = remainder, HL = quotient
   0098 C9                  228         ret
                            229 
   0099                     230 .morethan7bits:
   0099 06 09               231         ld      b,#9            ; at most 9 bits in quotient.
   009B 7D                  232         ld      a,l             ; precompute the first 7 shifts, by
   009C 6C                  233         ld      l,h             ;  doing 8
   009D 26 00               234         ld      h,#0
   009F CB 1D               235         rr      l               ;  undoing 1
   00A1                     236 .dvloop:
                            237         ;; Cleaned up on April 2009 by Marco Bodrato(http://bodrato.it/ )
                            238         ;; Shift next bit of quotient into bit 0 of dividend
                            239         ;; Shift next MSB of dividend into LSB of remainder
                            240         ;; A holds both dividend and quotient. While we shift a bit from
                            241         ;;  MSB of dividend, we shift next bit of quotient in from carry
                            242         ;; HL holds remainder
   00A1 ED 6A               243         adc     hl,hl           ; HL < 2^(7+9), no carry, ever.
                            244 
                            245         ;; If remainder is >= divisor, next bit of quotient is 1. We try
                            246         ;;  to compute the difference.
   00A3 ED 52               247         sbc     hl,de
   00A5 30 01               248         jr      NC,.nodrop      ; Jump if remainder is >= dividend
   00A7 19                  249         add     hl,de           ; Otherwise, restore remainder
                            250 	;; The add above sets the carry, because sbc hl,de did set it.
   00A8                     251 .nodrop:
   00A8 3F                  252         ccf                     ; Complement borrow so 1 indicates a
                            253                                 ;  successful substraction (this is the
                            254                                 ;  next bit of quotient)
   00A9 17                  255         rla
   00AA 10 F5               256         djnz    .dvloop
                            257         ;; Take care of the ninth quotient bit! after the loop B=0.
   00AC CB 10               258         rl      b               ; BA = quotient
                            259         ;; Carry now contains "0" = valid result.
   00AE 50                  260         ld      d,b
   00AF 5F                  261         ld      e,a             ; DE = quotient, HL = remainder
   00B0 EB                  262         ex      de,hl           ; HL = quotient, DE = remainder
   00B1 C9                  263         ret
                            264 
